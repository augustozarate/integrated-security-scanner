import requests
import time
import json
import hashlib
import os
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Optional
from rich.console import Console
from rich.table import Table
from rich.progress import Progress
from dataclasses import dataclass

@dataclass
class Vulnerability:
    """Clase para almacenar información de vulnerabilidades"""
    cve_id: str
    description: str
    cvss_score: float
    severity: str
    service_name: str
    port: int
    ip: str
    url: str
    published_date: str
    last_modified: str = ""
    exploit_available: bool = False
    
    def to_dict(self) -> Dict:
        return {
            'cve_id': self.cve_id,
            'description': self.description,
            'cvss_score': self.cvss_score,
            'severity': self.severity,
            'service': self.service_name,
            'port': self.port,
            'ip': self.ip,
            'url': self.url,
            'published_date': self.published_date,
            'last_modified': self.last_modified,
            'exploit_available': self.exploit_available
        }

class VulnerabilityScanner:
    """Escáner de vulnerabilidades con integración NIST API y caché"""
    
    def __init__(self, rate_limit_delay: float = 0.5):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self.rate_limit_delay = rate_limit_delay  # Delay entre requests a API
        self.console = Console()
        self.cache_file = "vuln_cache.json"
        self.cache = self._load_cache()
        self.api_stats = {'requests': 0, 'cache_hits': 0}
        
    def _load_cache(self) -> Dict:
        """Carga caché de vulnerabilidades"""
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def _save_cache(self):
        """Guarda caché en archivo"""
        try:
            import copy
            cache_copy = copy.deepcopy(self.cache)
            with open(self.cache_file, 'w') as f:
                json.dump(cache_copy, f, indent=2)
        except Exception as e:
            self.console.print(f"[yellow]Warning: Could not save cache: {e}[/yellow]")
    
    def _get_cache_key(self, service: str) -> str:
        """Genera clave única para caché"""
        return hashlib.md5(service.lower().encode()).hexdigest()
    
    def _is_cache_valid(self, cache_entry: Dict, max_age_days: int = 7) -> bool:
        """Verifica si la entrada de caché es válida (no muy antigua)"""
        if 'timestamp' not in cache_entry:
            return False
        
        cache_time = datetime.fromisoformat(cache_entry['timestamp'])
        return datetime.now() - cache_time < timedelta(days=max_age_days)
    
    def search_cves_for_service(self, service_info: Dict) -> List[Vulnerability]:
        """
        Busca CVEs para un servicio específico
        
        Args:
            service_info: Diccionario con información del servicio
                Ej: {'ip': '192.168.1.1', 'port': 80, 'service': 'Apache 2.4', 'banner': '...'}
        
        Returns:
            Lista de vulnerabilidades encontradas
        """
        service_name = service_info.get('service_name', '')
        version = service_info.get('version', '')
        ip = service_info.get('ip', '')
        port = service_info.get('port', 0)
        
        if not service_name:
            return []
        
        # Construir términos de búsqueda
        search_terms = [service_name]
        if version:
            search_terms.append(f"{service_name} {version}")
        
        all_vulnerabilities = []
        
        for term in search_terms:
            vulns = self._search_cves_nist(term, ip, port, service_name)
            all_vulnerabilities.extend(vulns)
        
        return all_vulnerabilities
    
    def _search_cves_nist(self, search_term: str, ip: str, port: int, service: str) -> List[Vulnerability]:
        """Busca CVEs usando la API del NIST"""
        cache_key = self._get_cache_key(search_term)
        
        # Verificar caché
        if cache_key in self.cache and self._is_cache_valid(self.cache[cache_key]):
            self.api_stats['cache_hits'] += 1
            cached_data = self.cache[cache_key]['data']
            return [
                Vulnerability(
                    cve_id=vuln_data['cve_id'],
                    description=vuln_data['description'],
                    cvss_score=vuln_data['cvss_score'],
                    severity=vuln_data['severity'],
                    service_name=vuln_data.get('service') or vuln_data.get('service_name', ''),  # Manejar ambas
                    port=port,
                    ip=ip,
                    url=vuln_data['url'],
                    published_date=vuln_data['published_date']
                ) for vuln_data in cached_data
            ]
        
        # Respeta el rate limiting
        time.sleep(self.rate_limit_delay)
        
        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={search_term}"
        
        try:
            response = requests.get(url, headers=self.headers, timeout=10)
            self.api_stats['requests'] += 1
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = self._parse_nist_response(data, ip, port, service)
                
                # Guardar en caché
                self.cache[cache_key] = {
                    'timestamp': datetime.now().isoformat(),
                    'data': [v.to_dict() for v in vulnerabilities]
                }
                self._save_cache()
                
                return vulnerabilities
            elif response.status_code == 429:
                self.console.print("[red]Rate limit exceeded. Waiting 10 seconds...[/red]")
                time.sleep(10)
                return self._search_cves_nist(search_term, ip, port, service)
            else:
                self.console.print(f"[yellow]API Error {response.status_code} for {search_term}[/yellow]")
                return []
                
        except requests.RequestException as e:
            self.console.print(f"[red]Request error for {search_term}: {e}[/red]")
            return []
    
    def _parse_nist_response(self, data: Dict, ip: str, port: int, service: str) -> List[Vulnerability]:
        """Parsea la respuesta de la API del NIST"""
        vulnerabilities = []
        
        if 'vulnerabilities' not in data:
            return vulnerabilities
        
        for vuln in data['vulnerabilities']:
            try:
                cve_data = vuln['cve']
                cve_id = cve_data.get('id', '')
                
                # Obtener descripción en inglés
                descriptions = cve_data.get('descriptions', [])
                description = next(
                    (desc['value'] for desc in descriptions if desc.get('lang') == 'en'),
                    'No description available'
                )
                
                # Obtener métricas CVSS v3 o v2
                metrics = cve_data.get('metrics', {})
                cvss_score = 0.0
                
                if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                    cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                    cvss_score = cvss_data.get('baseScore', 0.0)
                elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                    cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                    cvss_score = cvss_data.get('baseScore', 0.0)
                
                # Determinar severidad
                severity = self._get_severity(cvss_score)
                
                # Fechas
                published_date = cve_data.get('published', '')
                
                # URL del CVE
                url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
                
                vulnerability = Vulnerability(
                    cve_id=cve_id,
                    description=description[:200],  # Limitar longitud
                    cvss_score=float(cvss_score),
                    severity=severity,
                    service_name=service,
                    port=port,
                    ip=ip,
                    url=url,
                    published_date=published_date,
                    exploit_available=False  # Se podría verificar con otras APIs
                )
                
                # Filtrar solo vulnerabilidades relevantes (CVSS > 0)
                if cvss_score > 0:
                    vulnerabilities.append(vulnerability)
                    
            except (KeyError, ValueError) as e:
                continue
        
        return vulnerabilities
    
    def _get_severity(self, cvss_score: float) -> str:
        """Determina la severidad basada en el score CVSS"""
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        elif cvss_score > 0:
            return "LOW"
        else:
            return "UNKNOWN"
    
    def scan_services(self, services: List[Dict]) -> Dict[str, List[Vulnerability]]:
        """
        Escanea múltiples servicios para vulnerabilidades
        
        Args:
            services: Lista de diccionarios con información de servicios
        
        Returns:
            Diccionario con IP:Port como clave y vulnerabilidades como valor
        """
        results = {}
        
        with Progress() as progress:
            task = progress.add_task(
                "[cyan]Scanning for vulnerabilities...",
                total=len(services)
            )
            
            with ThreadPoolExecutor(max_workers=10) as executor:
                future_to_service = {
                    executor.submit(self.search_cves_for_service, service): service
                    for service in services
                }
                
                for future in as_completed(future_to_service):
                    service = future_to_service[future]
                    key = f"{service['ip']}:{service['port']}"
                    
                    try:
                        vulnerabilities = future.result()
                        results[key] = vulnerabilities
                    except Exception as e:
                        self.console.print(f"[red]Error scanning {key}: {e}[/red]")
                        results[key] = []
                    
                    progress.update(task, advance=1)
        
        return results
    
    def pretty_print_vulnerabilities(self, vulnerabilities: List[Vulnerability]):
        """Muestra vulnerabilidades en formato tabla"""
        if not vulnerabilities:
            self.console.print("[green]No vulnerabilities found.[/green]")
            return
        
        # Ordenar por severidad y CVSS
        vulnerabilities.sort(key=lambda x: (x.cvss_score, x.severity), reverse=True)
        
        table = Table(title="Vulnerabilities Found")
        table.add_column("CVE ID", style="cyan", no_wrap=True)
        table.add_column("Severity", style="bold")
        table.add_column("CVSS", justify="right")
        table.add_column("Service", style="magenta")
        table.add_column("Host:Port", style="yellow")
        table.add_column("Description", style="white")
        
        for vuln in vulnerabilities[:50]:  # Limitar a 50 resultados
            # Color basado en severidad
            if vuln.severity == "CRITICAL":
                severity_color = "[bold red]CRITICAL[/bold red]"
            elif vuln.severity == "HIGH":
                severity_color = "[red]HIGH[/red]"
            elif vuln.severity == "MEDIUM":
                severity_color = "[yellow]MEDIUM[/yellow]"
            elif vuln.severity == "LOW":
                severity_color = "[green]LOW[/green]"
            else:
                severity_color = "[white]UNKNOWN[/white]"
            
            # Truncar descripción
            desc = vuln.description
            if len(desc) > 60:
                desc = desc[:57] + "..."
            
            table.add_row(
                vuln.cve_id,
                severity_color,
                f"{vuln.cvss_score:.1f}",
                vuln.service_name,
                f"{vuln.ip}:{vuln.port}",
                desc
            )
        
        self.console.print(table)
        
        # Estadísticas
        critical = sum(1 for v in vulnerabilities if v.severity == "CRITICAL")
        high = sum(1 for v in vulnerabilities if v.severity == "HIGH")
        medium = sum(1 for v in vulnerabilities if v.severity == "MEDIUM")
        
        self.console.print(f"\n[cyan]Vulnerability Statistics:[/cyan]")
        self.console.print(f"  • Total vulnerabilities: {len(vulnerabilities)}")
        self.console.print(f"  • Critical: {critical}")
        self.console.print(f"  • High: {high}")
        self.console.print(f"  • Medium: {medium}")
        self.console.print(f"  • API Requests: {self.api_stats['requests']}")
        self.console.print(f"  • Cache hits: {self.api_stats['cache_hits']}")
    
    def generate_report(self, vulnerabilities: List[Vulnerability], filename: str = "vulnerability_report.md"):
        """Genera un reporte completo en Markdown"""
        with open(filename, 'w') as f:
            f.write("# Vulnerability Assessment Report\n\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            f.write("## Summary\n\n")
            f.write(f"- Total vulnerabilities found: {len(vulnerabilities)}\n")
            
            # Contar por severidad
            severities = {}
            for vuln in vulnerabilities:
                severities[vuln.severity] = severities.get(vuln.severity, 0) + 1
            
            for severity, count in sorted(severities.items(), key=lambda x: x[1], reverse=True):
                f.write(f"- {severity}: {count}\n")
            
            f.write("\n## Vulnerabilities Details\n\n")
            
            for vuln in sorted(vulnerabilities, key=lambda x: x.cvss_score, reverse=True):
                f.write(f"### {vuln.cve_id} - {vuln.severity}\n\n")
                f.write(f"- **CVSS Score**: {vuln.cvss_score:.1f}\n")
                f.write(f"- **Service**: {vuln.service_name}\n")
                f.write(f"- **Host**: {vuln.ip}:{vuln.port}\n")
                f.write(f"- **Published**: {vuln.published_date}\n")
                f.write(f"- **Description**: {vuln.description}\n")
                f.write(f"- **URL**: {vuln.url}\n\n")
        
        self.console.print(f"[green]Report generated: {filename}[/green]")